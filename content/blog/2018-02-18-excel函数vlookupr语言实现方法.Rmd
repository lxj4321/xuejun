---
title: EXCEL函数vlookup R语言实现方法
author: 刘学军
date: '2018-02-18'
slug: excel函数vlookupr语言实现方法
categories: ["编程"]
tags: ["R语言","EXCEL","vlookup"]
keyword: R语言
banner: "img/banners/9.jpg"
---

vlookup是EXCEL中应用比较多的函数，可以连接两表数据，但在应用中存在明显缺陷：  
1.在处理一对多数据时只能返回第一个值，在数据多时难以一一查找。  
2.数据较大时处理速度较慢。  
3.查找值必须在数据表第一列。  
R语言在连接两表时更加灵活、快捷。下面用R包tidyverse来实现vlookup功能： 

首先加载tidyverse包。
```{r loadpackage,message=FALSE}
library(tidyverse)
```

## 1 存在一一对应关系的两张表

### 1.1 连接**变量名**一致

数据表准备：数据可以用readxl包^[readxl包也是tidyverse包中的一个包，不像其他EXCEL数据输入输出包，它没外部依赖软件，例如Java等。]从EXCEL表中导入，也可以在R中直接输入,代码如下：
```{r}
"雇员1" <- tibble(
  "编码"=c("01001","01005","01009","01025"),
  "姓名"=c("张三","李四","王五","赵六"))

"人员信息1" <- tibble(
  "编码"=c("01001","01005","01009","01025"),
  "工资"=c(4500,5200,7000,7800),
  "部门"=c("管理部","技术部","财务部","财务部"))

```

数据表见表\@ref(tab:table-1),表\@ref(tab:table-2)
```{r table-1,echo=FALSE}
knitr::kable(雇员1,caption = "数据表1")
```

```{r table-2,echo=FALSE}
knitr::kable(人员信息1,caption = "数据表2")
```

**连接两表：**通过函数```left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)```连接两表，参数x为表一，y为表二，by为连接变量，见合并表\@ref(tab:table-3)。  

```{r,message=FALSE}
"合并表1" <- left_join(雇员1,人员信息1)
```

```{r table-3,echo=FALSE}
knitr::kable(合并表1,caption="合并表-1")
```

也可以指定by参数：```left_join(雇员1,人员信息1,by=  "编码")```


### 1.2 连接变量名不一致  
当连接变量名不一致时，可指定连接参数，如下表连接变量为编码---号码：

```{r}
"雇员2" <- tibble(
  "编码"=c("01001","01005","01009","01025"),
  "姓名"=c("张三","李四","王五","赵六"))

"人员信息2" <- tibble(
  "号码"=c("01001","01005","01009","01025"),
  "工资"=c(4500,5200,7000,7800),
  "部门"=c("管理部","技术部","财务部","财务部"))

```

```{r}
"合并表2" <- left_join(雇员2,人员信息2,by=  c("编码"="号码"))
```

```{r,echo=FALSE}
knitr::kable(合并表2,caption="合并表-2")
```


## 2 两表存在不一致数据  

下面两表最后一列数据不同

```{r}
"雇员3" <- tibble(
  "编码"=c("01001","01005","01009","01025"),
  "姓名"=c("张三","李四","王五","赵六"))

"人员信息3" <- tibble(
  "编码"=c("01001","01005","01009","01010"),
  "工资"=c(4500,5200,7000,7800),
  "部门"=c("管理部","技术部","财务部","财务部"))

```

```left_jion()```函数：以第一张表为基础匹配所有数据，无匹配的显示为空值。  
```{r}
"合并表3" <- left_join(雇员3,人员信息3,by="编码")
```

```{r,echo=FALSE}
knitr::kable(合并表3,caption="合并表-3")
```

```anti_jion()```函数：列出第一张表无匹配的数据，如表\@ref(tab:tab3),表\@ref(tab:tab4)

```{r}
"合并表4" <- anti_join(雇员3,人员信息3,by="编码")
```

```{r tab3,echo=FALSE}
knitr::kable(合并表4,caption="合并表-4")
```


```{r}
"合并表5" <- anti_join(人员信息3,雇员3,by="编码")
```

```{r tab4,echo=FALSE}
knitr::kable(合并表5,caption="合并表-5")
```

```inner_jion()```函数：只查找可匹配数据。  
```{r}
"合并表6" <- inner_join(雇员3,人员信息3,by="编码")
```

```{r,echo=FALSE}
knitr::kable(合并表6,caption="合并表-6")
```


## 3 两表存在一对多情况  
在EXCEL中vlookup只能匹配重复数据的第一个数据，数据多时难以核对重复数据。R语言中，可以匹配数据都会被匹配，这样容易筛选取舍。

```{r}
"雇员4" <- tibble(
  "编码"=c("01001","01005","01009","01010","01029"),
  "姓名"=c("张三","李四","王五","赵六","宝宝"))

"人员信息4" <- tibble(
  "编码"=c("01001","01005","01009","01010","01010","01010"),
  "工资"=c(4500,5200,7000,7800,12000,300),
  "部门"=c("管理部","技术部","财务部","财务部","技术部","管理部"))

```

下表中编号010010有三条重复数据，都被筛选匹配显示。
```{r}
"合并表7" <- left_join(雇员4,人员信息4,by="编码")
```

```{r,echo=FALSE}
knitr::kable(合并表7,caption="合并表-7")
```


两表数据多对多的情况如下：

```{r}
"雇员4" <- tibble(
  "编码"=c("01001","01005","01009","01010","01029","01010"),
  "姓名"=c("张三","李四","王五","赵六","宝宝","刘三"))

"人员信息4" <- tibble(
  "编码"=c("01001","01005","01009","01010","01010","01010"),
  "工资"=c(4500,5200,7000,7800,12000,300),
  "部门"=c("管理部","技术部","财务部","财务部","技术部","管理部"))

```

```{r}
"合并表8" <- left_join(人员信息4,雇员4,by="编码")
```

```{r,echo=FALSE}
knitr::kable(合并表8,caption="合并表-8")
```

数据表所有匹配可能都显示。
